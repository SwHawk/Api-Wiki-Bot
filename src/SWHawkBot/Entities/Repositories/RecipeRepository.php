<?php

namespace SWHawkBot\Entities\Repositories;

use Doctrine\ORM\EntityRepository;
use SWHawkBot\Constants;

/**
 * RecipeRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class RecipeRepository extends EntityRepository
{
    /**
     * Permet la traduction de la discipline
     *
     * @param string $discipline
     * @return string
     * @throws \InvalidArgumentException
     */
    private function trDiscipline($discipline)
    {
        if (!array_key_exists($discipline, Constants::$translation['crafting_disciplines']))
        {
            throw new \InvalidArgumentException("La discipline spécifiée n'existe pas (".$discipline.")");
        }
        return Constants::$translation['crafting_disciplines'][$discipline];
    }

    /**
     * Tente de transcrire le type en un type de recettes connu
     *
     * @param string $type
     * @return string
     */
    private function trType($type)
    {
        if (is_null($type) || $type == "")
        {
            throw new \InvalidArgumentException("La fonction attend un type sous forme de".
                " chaîne de caractères. Type donné : ".$type);
        }
        if (array_key_exists($type, Constants::$translation['recipe_types']))
        {
            return Constants::$translation['recipe_types'][$type];
        } else {
            return $type;
        }
    }

    /**
     * Détermine si les difficultés maximale
     * et minimales d'une recette sont correctes
     *
     * @param int $min
     * @param int $max
     * @return boolean
     */
    private function areValidMinMax($min, $max)
    {
        return $min >= 0 && $min <= 400 && $max > $min && $max <= 400;
    }

    /**
     * Retourne toutes les recettes d'une discipline
     * d'artisanat, triées par difficulté croissante
     *
     * @param string $discipline
     * @return \SWHawkBot\Entities\Recipe[]
     */
    private function getAllDisciplineRecipes($discipline)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb->select('r')
           ->from($this->getEntityName(),'r')
           ->where($qb->expr()->like('r.disciplines', ':discipline'))
           ->orderBy('r.difficulty','ASC')
           ->addOrderBy('r.type','ASC')
           ->setParameter('discipline', '%'.$discipline.'%');
        return $qb->getQuery()->getResult();
    }

    /**
     * Retourne toutes les recettes de forgeron
     * d'armure
     *
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getAllArmorsmithRecipes()
    {
        return $this->getAllDisciplineRecipes($this->trDiscipline('Armorsmith'));
    }

    /**
     * Retourne toutes les recettes d'artificier
     *
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getAllArtificerRecipes()
    {
        return $this->getAllDisciplineRecipes($this->trDiscipline('Artificer'));
    }

    /**
     * Retourne toutes les recettes de maître-queux
     *
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getAllChefRecipes()
    {
        return $this->getAllDisciplineRecipes($this->trDiscipline('Chef'));
    }

    /**
     * Retourne toutes les recettes de chasseur
     *
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getAllHuntsmanRecipes()
    {
        return $this->getAllDisciplineRecipes($this->trDiscipline('Huntsman'));
    }

    /**
     * Retourne toutes les recettes de bijoutier
     *
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getAllJewelerRecipes()
    {
        return $this->getAllDisciplineRecipes($this->trDiscipline('Jeweler'));
    }

    /**
     * Retourne toutes les recettes de travailleur
     * du cuir
     *
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getAllLeatherworkerRecipes()
    {
        return $this->getAllDisciplineRecipes($this->trDiscipline('LeatherWorker'));
    }

    /**
     * Retourne toutes les recettes de tailleur
     *
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getAllTailorRecipes()
    {
        return $this->getAllDisciplineRecipes($this->trDiscipline('Tailor'));
    }

    /**
     * Retourne toutes les recettes de forgeron
     * d'armes
     *
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getAllWeaponsmithRecipes()
    {
        return $$this->getAllDisciplineRecipes($this->trDiscipline('Weaponsmith'));
    }

    /**
     * Retourne les recettes d'une discipline ayant le type voulu
     * et une difficulté comprise entre $min et $max, destinée à
     * être wrappée par d'autres fonctions pour l'user input
     *
     * @param string $discipline
     * @param string $type
     * @param int $min
     * @param int $max
     * @return \SWHawkBot\Entities\Recipe[]
     */
    private function getDisciplineRecipesWithTypeAndDifficultyBetween($discipline, $type, $min, $max)
    {
        $qb = $this->getEntityManager()->createQueryBuilder();
        $qb->select('r')
        ->from($this->getEntityName(),'r')
        ->where(
            $qb->expr()->andX(

                $qb->expr()->between('r.difficulty', ':min', ':max')
            )
        )
        ->orderBy('r.difficulty', 'ASC')
        ->setParameter('discipline', '%'.$discipline.'%')
        ->setParameter('min', $min, 'integer')
        ->setParameter('max', $max, 'integer');
        if (!is_null($type) && $type != '')
        {
            $qb->andWhere($qb->expr()->like('r.type', ':type'))
               ->setParameter('type', '%'.$type.'%');
        }
        return $qb->getQuery()->getResult();
    }

    /**
     * Retourne les recettes de forgeron d'armure
     * ayant le type voulu et une difficulté
     * comprise entre $min et $max
     *
     * @param string $type
     * @param int $min
     * @param int $max
     * @throws \InvalidArgumentException
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getArmorsmithRecipesWithTypeAndDifficultyBetween($type, $min = 0, $max = 400)
    {
        $trType = $this->trType($type);
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Armorsmith'), $trType, $min, $max);
    }

    /**
     * Retourne les recettes d'artificier
     * ayant le type voulu et une difficulté
     * comprise entre $min et $max
     *
     * @param string $type
     * @param int $min
     * @param int $max
     * @throws \InvalidArgumentException
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getArtificerRecipesWithTypeAndDifficultyBetween($type, $min = 0, $max = 400)
    {
        $trType = $this->trType($type);
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Artificer'), $trType, $min, $max);
    }

    /**
     * Retourne les recettes de maître-queux
     * ayant le type voulu et une difficulté
     * comprise entre $min et $max
     *
     * @param string $type
     * @param int $min
     * @param int $max
     * @throws \InvalidArgumentException
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getChefRecipesWithTypeAndDifficultyBetween($type, $min = 0, $max = 400)
    {
        $trType = $this->trType($type);
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Chef'), $trType, $min, $max);
    }

    /**
     * Retourne les recettes de chasseur
     * ayant le type voulu et une difficulté
     * comprise entre $min et $max
     *
     * @param string $type
     * @param int $min
     * @param int $max
     * @throws \InvalidArgumentException
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getHuntsmanRecipesWithTypeAndDifficultyBetween($type, $min = 0, $max = 400)
    {
        $trType = $this->trType($type);
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Huntsman'), $trType, $min, $max);
    }

    /**
     * Retourne les recettes de bijoutier
     * ayant le type voulu et une difficulté
     * comprise entre $min et $max
     *
     * @param string $type
     * @param int $min
     * @param int $max
     * @throws \InvalidArgumentException
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getJewelerRecipesWithTypeAndDifficultyBetween($type, $min = 0, $max = 400)
    {
        $trType = $this->trType($type);
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Jeweler'), $trType, $min, $max);
    }

    /**
     * Retourne les recettes de travailleur du cuir
     * ayant le type voulu et une difficulté
     * comprise entre $min et $max
     *
     * @param string $type
     * @param int $min
     * @param int $max
     * @throws \InvalidArgumentException
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getLeatherworkerRecipesWithTypeAndDifficultyBetween($type, $min = 0, $max = 400)
    {
        $trType = $this->trType($type);
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Leatherworker'), $trType, $min, $max);
    }

    /**
     * Retourne les recettes de tailleur
     * ayant le type voulu et une difficulté
     * comprise entre $min et $max
     *
     * @param string $type
     * @param int $min
     * @param int $max
     * @throws \InvalidArgumentException
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getTailorRecipesWithTypeAndDifficultyBetween($type, $min = 0, $max = 400)
    {
        $trType = $this->trType($type);
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Tailor'), $trType, $min, $max);
    }

    /**
     * Retourne les recettes de forgeron d'armes
     * ayant le type voulu et une difficulté
     * comprise entre $min et $max
     *
     * @param string $type
     * @param int $min
     * @param int $max
     * @throws \InvalidArgumentException
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getWeaponsmithRecipesWithTypeAndDifficultyBetween($type, $min = 0, $max = 400)
    {
        $trType = $this->trType($type);
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Weaponsmith'), $trType, $min, $max);
    }

    /**
     * Retourne les recettes de forgeron d'armures
     * ayant le type voulu
     *
     * @param string $type
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getArmorsmithRecipesWithType($type)
    {
        $trType = $this->trType($type);
        return $this->getArmorsmithRecipesWithTypeAndDifficultyBetween($trType);
    }

    /**
     * Retourne les recettes d'artificer
     * ayant le type voulu
     *
     * @param string $type
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getArtificerRecipesWithType($type)
    {
        $trType = $this->trType($type);
        return $this->getArtificerRecipesWithTypeAndDifficultyBetween($trType);
    }

    /**
     * Retourne les recettes de maître-queux
     * ayant le type voulu
     *
     * @param string $type
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getChefRecipesWithType($type)
    {
        $trType = $this->trType($type);
        return $this->getChefRecipesWithTypeAndDifficultyBetween($trType);
    }

    /**
     * Retourne les recettes de chasseur
     * ayant le type voulu
     *
     * @param string $type
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getHuntsmanRecipesWithType($type)
    {
        $trType = $this->trType($type);
        return $this->getHuntsmanRecipesWithTypeAndDifficultyBetween($trType);
    }

    /**
     * Retourne les recettes de bijoutier
     * ayant le type voulu
     *
     * @param string $type
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getJewelerRecipesWithType($type)
    {
        $trType = $this->trType($type);
        return $this->getJewelerRecipesWithTypeAndDifficultyBetween($trType);
    }

    /**
     * Retourne les recettes de travailleur du cuir
     * ayant le type voulu
     *
     * @param string $type
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getLeatherworkerRecipesWithType($type)
    {
        $trType = $this->trType($type);
        return $this->getLeatherworkerRecipesWithTypeAndDifficultyBetween($trType);
    }

    /**
     * Retourne les recettes de tailleur
     * ayant le type voulu
     *
     * @param string $type
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getTailorRecipesWithType($type)
    {
        $trType = $this->trType($type);
        return $this->getTailorRecipesWithTypeAndDifficultyBetween($trType);
    }

    /**
     * Retourne les recettes de forgeron d'armes
     * ayant le type voulu
     *
     * @param string $type
     * @return \SWHawkBot\Entities\Recipe[]
     */
    public function getWeaponsmithRecipesWithType($type)
    {
        $trType = $this->trType($type);
        return $this->getWeaponsmithRecipesWithTypeAndDifficultyBetween($trType);
    }

    /**
     * Retourne les recettes de forgeron d'armures
     * dont la difficulté est comprise entre $min
     * et $max
     *
     * @param int $min
     * @param int $max
     * @return \SWHawkBot\Entities\Recipes[]
     */
    public function getArmorsmithRecipesWithDifficultyBetween($min = 0, $max = 400)
    {
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Armorsmith'), null, $min, $max);
    }

    /**
     * Retourne les recettes d'artificier
     * dont la difficulté est comprise entre $min
     * et $max
     *
     * @param int $min
     * @param int $max
     * @return \SWHawkBot\Entities\Recipes[]
     */
    public function getArtificerRecipesWithDifficultyBetween($min = 0, $max = 400)
    {
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Artificer'), null, $min, $max);
    }

    /**
     * Retourne les recettes de maître-queux
     * dont la difficulté est comprise entre $min
     * et $max
     *
     * @param int $min
     * @param int $max
     * @return \SWHawkBot\Entities\Recipes[]
     */
    public function getChefRecipesWithDifficultyBetween($min = 0, $max = 400)
    {
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Chef'), null, $min, $max);
    }

    /**
     * Retourne les recettes de chasseur
     * dont la difficulté est comprise entre $min
     * et $max
     *
     * @param int $min
     * @param int $max
     * @return \SWHawkBot\Entities\Recipes[]
     */
    public function getHuntsmanRecipesWithDifficultyBetween($min = 0, $max = 400)
    {
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Huntsman'), null, $min, $max);
    }

    /**
     * Retourne les recettes de bijoutier
     * dont la difficulté est comprise entre $min
     * et $max
     *
     * @param int $min
     * @param int $max
     * @return \SWHawkBot\Entities\Recipes[]
     */
    public function getJewelerRecipesWithDifficultyBetween($min = 0, $max = 400)
    {
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Jeweler'), null, $min, $max);
    }

    /**
     * Retourne les recettes de travailleur du cuir
     * dont la difficulté est comprise entre $min
     * et $max
     *
     * @param int $min
     * @param int $max
     * @return \SWHawkBot\Entities\Recipes[]
     */
    public function getLeatherWorkerRecipesWithDifficultyBetween($min = 0, $max = 400)
    {
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Leatherworker'), null, $min, $max);
    }

    /**
     * Retourne les recettes de tailleur
     * dont la difficulté est comprise entre $min
     * et $max
     *
     * @param int $min
     * @param int $max
     * @return \SWHawkBot\Entities\Recipes[]
     */
    public function getTailorRecipesWithDifficultyBetween($min = 0, $max = 400)
    {
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Tailor'), null, $min, $max);
    }

    /**
     * Retourne les recettes de forgeron d'armes
     * dont la difficulté est comprise entre $min
     * et $max
     *
     * @param int $min
     * @param int $max
     * @return \SWHawkBot\Entities\Recipes[]
     */
    public function getWeaponsmithRecipesWithDifficultyBetween($min = 0, $max = 400)
    {
        if (!$this->areValidMinMax($min, $max)) {
            throw new \InvalidArgumentException("La fonction attend un minimum et un maximum entiers".
                " et compris entre 0 et 400. Min et Max donnés : ".$min." et ".$max);
        }
        return $this->getDisciplineRecipesWithTypeAndDifficultyBetween(
            $this->trDiscipline('Weaponsmith'), null, $min, $max);
    }


}
